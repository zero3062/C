#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>

int main(int argc, char *argv[]){

	int fd;
	struct flock filelock;

	filelock.l_type = F_WRLCK; /*쓰기 잠금*/
	filelock.l_whence = SEEK_SET; /*파일의 시작을 기준으로*/
	filelock.l_start = 0; /*기준의 처음부터*/

	fd = open(argv[1], O_RDWR); /*argv[1] 파일 열기*/

	/*fork에 의해 자식 프로세스를 생성*/
	switch(fork()) {
		/*fork 호출에 실패하면*/
		case -1:
			perror("fork failed");
			exit(1);
		/*자식 프로세스는 */
		case 0: 
			filelock.l_len = 5; /*5바이트 크기에 대해*/
			/*fd파일에 대해 레코드 잠금을 설정
			  이미 레코드 잠금이 설정되어 있으면 해제될 때까지 기다림*/
			if(fcntl(fd, F_SETLKW, &filelock) == -1) {
				perror("fcntl failed");
				exit(1);
			}
			printf("chiled process: locked\n");
			sleep(3);
			/*레코드 잠금을 해제*/
			filelock.l_type = F_UNLCK;
			if(fcntl(fd, F_SETLK, &filelock) == -1) {
				perror("fcntl failed");
				exit(1);
			}
			printf("child process: unlocked\n");
			break;
		/*부모 프로세스는*/
		default:
			filelock.l_len = 10; /*10바이트 크기에 대해*/
			/*fd파일에 대해 레코드 잠금을 설정*/
			if(fcntl(fd, F_SETLKW, &filelock) == -1) {
				perror("fcntl failed");
				exit(1);
			}
			printf("parent process : locked\n");
			sleep(3);
			/*레코드 잠금을 해제*/
			filelock.l_type = F_UNLCK;
			if(fcntl(fd, F_SETLK, &filelock) == -1) {
				perror("fcntl failed");
				exit(1);
			}
			printf("parent proccess :unlocked\n");
			/*자식 프로세스가 종료될 때까지 기다림*/
			wait(NULL);
	}
	exit(0);
}
